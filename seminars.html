<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schedule - Paris ACTS</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Paris Automata and Concurrency Theory Seminar</h1>
        <h2>(Paris ACTS)</h2>
    </header>
    
    <nav>
        <a href="index.html" class="nav-link">Home</a>
        <a href="seminars.html" class="nav-link">Seminars</a>
        <a href="committee.html" class="nav-link">Committees</a>
        <a href="local-info.html" class="nav-link active">Local Information</a>
    </nav>
    
    <main>
        <section id="upcoming-seminars">
          <h2>Upcoming Seminars</h2>
          <article class="seminar-item">
            <h3 class="seminar-date">29 January 2025</h3>
            <p><strong>Venue:</strong> IRIF, Université Paris Cité</p>
            <p><strong>Speaker 1:</strong> (present) <em>Laetitia Laversa</em>, IRIF, Université Paris Cité, France</p>
            <p><strong>Title:</strong> About the <i>k</i>-synchronizability of communicating automata</p>
	    <p><strong>Abstract:</strong>
	      Distributed systems are ubiquitous and their implementation is complex and error-prone. In order to check for errors, they can be modeled as systems of communicating automata, where each automaton represents the behavior of an element of the system. Verification problems such as reachability are undecidable in such a model. Indeed, a system of communicating automata is Turing-equivalent. For that, the use of approximations is necessary. <i>k</i>-synchronizability is one of these techniques. A system is <i>k</i>-synchronizable if, for all executions, there is an equivalent execution that can be divided into phases containing <i>k</i> messages. These phases are called <i>k</i>-exchanges. In this presentation, we will discuss the different results that make this class so interesting.
	    </p>
            <p><strong>Speaker 2:</strong> (present) <em>Glynn Winskel</em>, Queen Mary University of London, UK</p>
            <p><strong>Title:</strong> From Concurrent Games to Gödel's Dialectica Interpretation</p>
	    <p><strong>Abstract:</strong>
	      Computation today is highly distributed and interactive.  Event structures represent computation in terms of causal dependency and conflict relations on events; the relations make precise the sense in which events can occur concurrently (independently, in parallel). By redeveloping games in sufficient generality, as event structures, interactive computation becomes a strategy and its type a game.  Then the dichotomy between a system and its environment is caught in the distinction between Player and Opponent moves.  A functional approach has to handle the dichotomy much more ingeniously, through its blunter distinction between input and output. This has led to a variety of functional approaches, specialised to particular interactive demands. A surprise in the development of concurrent games has been that several, seemingly disparate, historical approaches in logic and computation reappear as special cases.  They include stable domain theory; nondeterministic dataflow; geometry of interaction; the dialectica interpretation; lenses and optics; and their extensions to containers in dependent lenses and optics.
	    </p>
          </article>
        </section>
        
        <section id="past-seminars">
          <h2>Past Seminars</h2>
          <article class="seminar-item">
            <h3 class="seminar-date">10 October 2024</h3>
            <p><strong>Venue:</strong> LRE, EPITA Paris</p>
            <p><strong>Speaker 1:</strong> (present) <em>Uli Fahrenberg</em>, EPITA</p>
            <p><strong>Title:</strong> Introduction to Paris ACTS</p>
            
            <span class="toggle-abstract" style="cursor: pointer;">► <strong>Abstract:</strong></span>
            <p class="abstract-content">
              <span class="abstract-first-line">                   
              </span> 
              <span class="full-abstract" style="display:none;">
                I will give an introduction to the purpose of the Paris ACTS seminar series and to the intersection between 
                automata and concurrency theory at which it is situated. I will  finish by introducing a notion of specification theories that we developed some years 
                ago and which is related to the refinement calculus of the second speaker.
              </span>
            </p>
	    
            <p><strong>Speaker 2:</strong> (online) <em>Ian Hayes</em>, University of Queensland, Brisbane, Australia</p>
            <p><strong>Title:</strong> Concurrent Refinement Algebra</p>
	    
            <span class="toggle-abstract" style="cursor: pointer;">► <strong>Abstract:</strong></span>
            <p class="abstract-content">
              <span class="abstract-first-line">                  
              </span>
              <span class="full-abstract" style="display:none;">
                Our goal is to develop a refinement calculus for shared-memory concurrent programs that 
                supports Jones-style rely/guarantee  developments. Our semantics is based on Aczel traces, 
                which explicitly include environment transitions as well as program transitions, and were 
                originally proposed as a basis for showing the rely/guarantee rules of Jones are sound. 
                Our approach has been to develop a hierarchy of algebraic theories that provide a foundation 
                for concurrent program refinement. Our algebraic theory is based on a lattice of commands 
                that includes a sub-lattice of test commands (similar to Kozen's Kleene Algebra with Tests) 
                and a sub-algebra of atomic commands (similar to Milner's SCCS but with a richer structure 
                that supports Aczel's program and environment transitions). Rely and guarantee conditions 
                are encoded as commands within the theory, and refinement laws for deriving concurrent 
                programs from rely/guarantee specifications can be proven within the theory.
              </span>
            </p>
          </article>

          <article class="seminar-item">
            <h3 class="seminar-date">26 November 2024</h3>
            <p><strong>Venue:</strong> LIX, École polytechnique</p>
            <p><strong>Speaker 1:</strong> (present) <em>Enzo Erlich</em>, IRIF, Université Paris Cité, France</p>
            <p><strong>Title:</strong> Expressivity of First Order and Temporal Logics for Pomset Languages</p>
            
            <span class="toggle-abstract" style="cursor: pointer;">► <strong>Abstract:</strong></span>
            <p class="abstract-content">
              <span class="abstract-first-line">                   
              </span> 
              <span class="full-abstract" style="display:none;">
	      We introduce a temporal logic for pomset languages, which we call Sparse-based Pomset Temporal Logic (SPTL). SPTL draws significant inspiration from Linear Temporal Logic (LTL). We show that, under a reasonable hypothesis, SPTL is as expressive as a First Order (FO) logic for pomset languages that we introduce. This extends Kamp's theorem, which states that LTL has the same expressive power as FO logic over words. To do this, we apply Kamp's theorem to ST-sequences, which are representations of pomsets over words, and provide successive translations over different logics.
              </span>
            </p>
	    
            <p><strong>Speaker 2:</strong> (online) <em>Masaki Waga</em>, Kyoto University, Japan
            <p><strong>Title:</strong> Active Learning of Deterministic Timed Automata with Myhill-Nerode Style Characterization</p>
	    
            <span class="toggle-abstract" style="cursor: pointer;">► <strong>Abstract:</strong></span>
            <p class="abstract-content">
              <span class="abstract-first-line">                  
              </span>
              <span class="full-abstract" style="display:none;">
	      We present an algorithm to learn a deterministic timed automaton (DTA)
	      via membership and equivalence queries. Our algorithm is an extension of
	      the L* algorithm with a Myhill-Nerode style characterization of
	      recognizable timed languages, which is the class of timed languages
	      recognizable by DTAs. We first characterize the recognizable timed
	      languages with a Nerode-style congruence. Using it, we give an algorithm
	      with a smart teacher answering symbolic membership queries in addition
	      to membership and equivalence queries. With a symbolic membership query,
	      one can ask the membership of a certain set of timed words at one
	      time. We prove that for any recognizable timed language, our learning
	      algorithm returns a DTA recognizing it. We show how to answer a symbolic
	      membership query with finitely many membership queries. We also show
	      that our learning algorithm requires a polynomial number of queries with
	      a smart teacher and an exponential number of queries with a normal
	      teacher. We applied our algorithm to various benchmarks and confirmed
	      its effectiveness with a normal teacher.
              </span>
            </p>
          </article>
        </section>
        
    </main>        
    
    <script src="script.js"></script>

    <footer>
        <p>&copy; 2024 Paris Automata and Concurrency Theory Seminar (Paris ACTS)</p>
        <div class="footer-logos">
            <a href="https://www.irif.fr/">
                <img src="irif-logo.png" alt="IRIF Logo">
            </a>
            <a href="https://www.lix.polytechnique.fr/">
                <img src="lix-logo.png" alt="LIX Logo">
            </a>
            <a href="https://www.lre.epita.fr/">
                <img src="lre-logo.png" alt="LRE Logo">
            </a>
        </div>
    </footer>
</body>
</html>
